name: Deploy in dev & Validate version

on:
  workflow_call:

jobs:
  deploy-dev:
    name: Deploy in Dev
    runs-on: ubuntu-latest
    environment: dev
    permissions:
      id-token: write
      contents: read
    env:
      NODE_VERSION: 16.14.0
      GO_VERSION: 1.17
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Create workflow information file
        run: |
          import configparser
          from datetime import datetime
          import json, os

          read_version = configparser.ConfigParser()
          read_version.read("VERSION.ini")
          version = read_version.get('APP', 'version')

          commit_sha = os.getenv("GITHUB_SHA")
          short_hash = commit_sha[:7]
          run_id = os.getenv("GITHUB_RUN_ID")
          dev_version = f"{version}-{short_hash}-{run_id}"

          pipeline_details ={
            "name" : os.getenv("GITHUB_WORKFLOW"),
            "date" : datetime.now().strftime("%Y-%m-%dT%H:%M:%SZ"),
            "version" : dev_version,
            "runId" :run_id,                
            "branch" : os.getenv("GITHUB_REF_NAME")
          }
            
          json_object = json.dumps(pipeline_details, indent = 4)
          workspace_path = os.getenv("GITHUB_WORKSPACE")
            
          with open(f"{workspace_path}/backend/mainmodule/workflow_info.json", "w") as outfile:
              outfile.write(json_object)

        shell: python

      - name: Setup Nodejs ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Setup Go ${{ env.GO_VERSION }}
        uses: actions/setup-go@v3
        with:
          go-version: ${{ env.GO_VERSION }}

      - name: Install dependencies
        run: make install

      # - name: Read region from sst.json
      #   id: get_aws_region
      #   run: |
      #     region=`python3 -c "
      #     import json
          
      #     with open('sst.json', 'r') as f:
      #       sst_data = json.load(f)
      #     print(sst_data['region'])"`
      #     echo "::set-output name=aws_region::$region"

      # - name: Configure aws
      #   uses: aws-actions/configure-aws-credentials@v1
      #   with:
      #     role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE }}
      #     role-session-name: GithubCDActions
      #     aws-region: ${{ steps.get_aws_region.outputs.aws_region }}

      # - name: Deploy stack
      #   run: make deploy stage="dev"

      # - name: Add action summary
      #   env:
      #     REPO: ${{ github.event.repository.name }}
      #     REPO_URL: ${{ github.event.repository.html_url }}
      #   run: |
      #     branchUrl=${REPO_URL}/tree/${GITHUB_REF_NAME}
      #     echo "## Sources" >> $GITHUB_STEP_SUMMARY
      #     echo "|Repository|Branch|" >> $GITHUB_STEP_SUMMARY
      #     echo "|---|---|" >> $GITHUB_STEP_SUMMARY
      #     echo "|<a href='${REPO_URL}'>${REPO}</a>|"\
      #           "<a href='${branchUrl}'>${GITHUB_REF_NAME}</a>|" >> $GITHUB_STEP_SUMMARY

  validate-version:
    name: Validate Version
    runs-on: ubuntu-latest
    continue-on-error: true
    outputs:
      outcome: ${{ env.outcome }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Check if version is in semantic format
        id: version_semantic
        run: |
          pip install semantic_version
          vers=`python3 -c "
          import configparser
          import semantic_version
          read_version = configparser.ConfigParser()
          read_version.read('VERSION.ini')
          version = read_version.get('APP', 'version')
          if semantic_version.validate(version):
            print(version)
          else:
            print('Error: Version not in semantic format')"`
          if [[ $vers == *"Error"* ]]; then
            echo $vers
            exit 1
          fi
          echo "Version - "$vers
          echo "::set-output name=version::$vers"

      - name: Check if version is in ChangeLog file
        run: |
          version=${{ steps.version_semantic.outputs.version }}
          echo "version is: ${version}"
          chgLog=`grep -q "$version" CHANGELOG.md; [ $? -eq 0 ] && echo "Y" || echo "N"`
          if [[ $chgLog == "N" ]]; then
            echo "Error: Version not available in CHANGELOG.md file"
            exit 1
          fi

      - name: Check if git tag already exists
        run: |
          version=${{ steps.version_semantic.outputs.version }}
          echo "version is: ${version}"
          tag=$(git tag -l "$version")
          if [ ! -z "$tag" ]; then
            echo "ERROR: Git tag already exists"
            exit 1
          fi

      - name: Check if tag has the right sequential format
        run: |
          baseline='N'
          if [ ! $(git describe --tags `git rev-list --tags --max-count=1`) &> /dev/null ]; then
            echo "Error: Git tag need to baselined first"
            exit 1
          else
            baseline='Y'
            ver=$(git describe --tags `git rev-list --tags --max-count=1`)
          fi
          version=${{ steps.version_semantic.outputs.version }}
          echo "version is: ${version}"
          if [[ $baseline == 'Y' ]]; then
          t_current_version=`echo ${version}`
          no_sequence=`python3 -c "
          import semantic_version
          v = semantic_version.Version('''$ver''')
          v_major = v.next_major()
          v_minor = v.next_minor()
          v_patch = v.next_patch()
          if('''$t_current_version''' != str(v_major) and '''$t_current_version''' != str(v_minor) and '''$t_current_version''' != str(v_patch)):              
            print('Y')
          else:
            print('N')"`           
          if [[ $no_sequence != "N" ]]; then
            echo "Error: Version not in sequential format"
            exit 1
          fi
          fi

      - name: Set Validate version outcome to success
        run: echo "outcome=success" >> $GITHUB_ENV

  tag-version-git:
    name: Tag version in GIT
    runs-on: ubuntu-latest
    if: ${{ needs.deploy-dev.result == 'success' && needs.validate-version.outputs.outcome == 'success' }}
    needs: [deploy-dev, validate-version]
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Create tag with version
        env:  
          # TODO: parameterize this from the cli when ready
          GIT_USER: kiran.siddagangappa
          GIT_MAIL: kiran.siddagangappa@analog.com
        run: |
          vers=`python3 -c "
          import configparser
          read_version = configparser.ConfigParser()
          read_version.read('VERSION.ini')
          version = read_version.get('APP', 'version')
          print(version)"`

          git config user.name "$GIT_USER"
          git config user.email "$GIT_MAIL"
          message="Tagged by Automated deploy in dev job, Run Number: $GITHUB_RUN_ID"
          git tag "$vers" -m "$message"
          git push origin "$vers"
          echo "git tag '$vers' created"
